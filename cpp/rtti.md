https://www.cnblogs.com/sunyichao/p/14353355.html

RTTI是运行阶段类型识别（Runtime Type Identification）的简称。

> 这是新添加到C++中的特性之一，很多老式实现不支持。另一些实现可能包含开关RTTI的编译器设置。

RTTI旨在为程序再运行阶段确定对象的类型提供一种标准方式。很多类库已经为其类对象提供了实现这种功能的方式，但由于C++内部并不支持，因此各个厂商的机制通常互不兼容，创建一种RTTI语言标准将使得未来的库能够彼此兼容。

## RTTI的用途

假设有一个类层次结构，其中的类都是从一个基类派生而来的，则可以让基类指针指向其中任何一个类的对象。

有时候我们会想要知道指针具体指向的是哪个类的对象。因为：

- 可能希望调用类方法的正确版本，而有时候派生对象可能包含不是继承而来的方法，此时，只有某些类的对象可以使用这种方法。
- 也可能是出于调试目的，想跟踪生成的对象的类型。

## RTTI的工作原理

C++有3个支持RTTI的元素：

- 如果可能的话，`dynamic_cast`运算符将使用一个指向基类的指针来生成一个指向派生类的指针；否则，该运算符返回0（空指针）；
- `typeid`运算符返回一个指出对象的类型的值；
- `type_info`结构存储了有关特定类型的信息。

### 1. dynamic_cast运算符

这是最常用的RTTI组件，它不能回答“指针指向的是哪类对象”这样的问题，但能够回答“是否可以安全地将对象的地址赋给特定类型的指针”这样的问题。

> 说白了，就是看看这个对象指针能不能转换为目标指针。

通常，如果指向的对象（`*pt`）的类型为Type或者是从Type直接或简介派生而来的类型，则下面的表达式将指针`pt`转换为Type类型的指针：

```cpp
dynamic_cast<Type *>(pt)
```

否则，结果为0，即空指针。

> **注意**：即使编译器支持RTTI，在默认情况下，它也可能关闭该特性。如果该特性被关闭，程序可能仍能够通过编译，但将出现运行阶段错误。在这种情况下，应该查看文档或菜单选项。

也可以将`dynamic_cast`用于**引用**，用法稍微有点不同：

没有与空指针对应的引用值，因此无法使用特殊的引用值来指示失败。当请求不正确时，`dynamic_cast`将引发类型为`bad_cast`的异常，这种异常是从`exception`类派生而来的，它是在头文件**typeinfo**中定义的。

```cpp
#include <typeinfo> // for bad_cast
...
try {
	Basic & rs = dynamic_cast<Basic &>(rt);
	...
}
catch(bad_cast &){
	...
};
```

### 2. typeid运算符和type_info类

`typeid`运算符能够用于确定两个对象是否为同种类型。它与sizeof有些想象，可以接受两种参数：

- 类名；
- 结果为对象的表达式。

返回一个对`type_info`**对象的引用**，其中，`type_info`是在头文件`typeinfo`中定义的一个类，这个类重载了`==`和`!=`运算符，以便可以用于对类型进行比较。

```cpp
// 判断pg指向的是否是ClassName类的对象
typeid(ClassName) == typeid(*pg)
```

如果pg是一个空指针，程序将引发`bad_typeid`异常，该异常是从`exception`类派生而来的，它是在头文件**typeinfo**中声明的。

`type_info`类的实现随厂商而异，但包含一个`name()`成员，该函数返回一个随实现而异的字符串，通常（但并非一定）是类的名称。可以这样显示：

```cpp
std::cout << "Now processing type is " << typeid(*pg).name() << ".\\n";
```

其实，`typeid`运算符就是指出或判断具体的类型，而`dynamic_cast`运算符主要用于判断是否能够转换，并进行类型转换（指针或引用）。

### 3. 误用RTTI的例子

有些人对RTTI口诛笔伐，认为它是多余的，会导致程序效率低下和糟糕的编程方式。这里有一个需要尽量避免的例子。

在判断是否能调用某个方法时，尽量不要使用`if-else`和`typeid`的形式，因为这会使得代码冗长。

如果在扩展的`if else`语句系列中使用了`typeid`，则应该考虑是否应该使用虚函数和`dynamic_cast`。