# Clang-Repl

Clang-Repl is a C++ interpreter: https://clang.llvm.org/docs/ClangRepl.html

Let's take a look at how to use clang-repl.

```c++
clang-repl> #include <iostream>
clang-repl> int sum(int a, int b){ return a+b; };
clang-repl> int c = sum(9,10);
clang-repl> std::cout << c << std::endl;
19
```

You can see that clang-repl will execute your code line by line.

Now consider a question: Will clang repl recompile the entire code when you add a new line of code?

Absolutely not, that's too slow.

Actually, there is an important module called libIncremental in clang-repl that can only compile newly added lines of code.

# Debugging

The main function of clang-repl is located in file **clang/tools/clang-repl/ClangRepl.cpp**.

The core code of clang-repl is located in directory  **clang/lib/Interpreter**.

The following code analysis is based on **the main branch of LLVM, commit fdccfa33d96b1935e90a9148a661f51ea8b46aa3**.

In the main function, you will see a loop that processes the user's input code line by line:

```c++
// clang/tools/clang-repl/ClangRepl.cpp: 228
while (std::optional<std::string> Line = LE.readLine()) {
```

We mainly focus on function `Interpreter::ParseAndExecute`, which will parse and execute our input code:

``` cpp
// clang/tools/clang-repl/ClangRepl.cpp: 252
else if (auto Err = Interp->ParseAndExecute(Input)) {
```

`Interpreter::ParseAndExecute` mainly calls two functions, `Interpreter::Parse` and `Interpreter::Execute`. Here we only focus on the incremental construction of AST, so we only focus on the function `Interpreter::Parse`.

```c++
// clang/lib/Interpreter/Interpreter.cpp: 396
auto PTU = Parse(Code);
```

`Interpreter::Parse` will call `IncrementalParser::Parse`. Let's see its workflow:

(1) Create a new memory buffer for the input code:

```cpp
// clang/lib/Interpreter/IncrementalParser.cpp: 309
  std::ostringstream SourceName;
  SourceName << "input_line_" << InputCount++;

  // Create an uninitialized memory buffer, copy code in and append "\n"
  size_t InputSize = input.size(); // don't include trailing 0
  // MemBuffer size should *not* include terminating zero
  std::unique_ptr<llvm::MemoryBuffer> MB(
      llvm::WritableMemoryBuffer::getNewUninitMemBuffer(InputSize + 1,
                                                        SourceName.str()));
  char *MBStart = const_cast<char *>(MB->getBufferStart());
  memcpy(MBStart, input.data(), InputSize);
  MBStart[InputSize] = '\n';
```

(2) Configure Preprocessor and Lexer:

```cpp
// clang/lib/Interpreter/IncrementalParser.cpp: 328
  // Create FileID for the current buffer.
  FileID FID = SM.createFileID(std::move(MB), SrcMgr::C_User, /*LoadedID=*/0,
                               /*LoadedOffset=*/0, NewLoc);

  // NewLoc only used for diags.
  if (PP.EnterSourceFile(FID, /*DirLookup=*/nullptr, NewLoc))
    return llvm::make_error<llvm::StringError>("Parsing failed. "
                                               "Cannot enter source file.",
                                               std::error_code());
```

(3) Call `ParseOrWrapTopLevelDecl`:

```cpp
// clang/lib/Interpreter/IncrementalParser.cpp: 338
auto PTU = ParseOrWrapTopLevelDecl();
```

(3.1) Create a new TranslationUnit:

```cpp
// clang/lib/Interpreter/IncrementalParser.cpp: 249
  PTUs.emplace_back(PartialTranslationUnit());
  PartialTranslationUnit &LastPTU = PTUs.back();
  // Add a new PTU.
  ASTContext &C = S.getASTContext();
  C.addTranslationUnitDecl();
  LastPTU.TUPart = C.getTranslationUnitDecl();
```

(3.2) Skip the previous EOF and enter the new TranslationUnit:

```cpp
// clang/lib/Interpreter/IncrementalParser.cpp: 256
  // Skip previous eof due to last incremental input.
  if (P->getCurToken().is(tok::annot_repl_input_end)) {
    P->ConsumeAnyToken();
    // FIXME: Clang does not call ExitScope on finalizing the regular TU, we
    // might want to do that around HandleEndOfTranslationUnit.
    P->ExitScope();
    S.CurContext = nullptr;
    // Start a new PTU.
    P->EnterScope(Scope::DeclScope);
    S.ActOnTranslationUnitScope(P->getCurScope());
  }
```

(3.3) Incremental compilation:

```cpp
// clang/lib/Interpreter/IncrementalParser.cpp: 270
  for (bool AtEOF = P->ParseFirstTopLevelDecl(ADecl, ImportState); !AtEOF;
       AtEOF = P->ParseTopLevelDecl(ADecl, ImportState)) {
    if (ADecl && !Consumer->HandleTopLevelDecl(ADecl.get()))
      return llvm::make_error<llvm::StringError>("Parsing failed. "
                                                 "The consumer rejected a decl",
                                                 std::error_code());
  }
  ...
  // Process any TopLevelDecls generated by #pragma weak.
  for (Decl *D : S.WeakTopLevelDecls()) {
    DeclGroupRef DGR(D);
    Consumer->HandleTopLevelDecl(DGR);
  }
  ...
  Consumer->HandleTranslationUnit(C);
```

Taken overall, clang-repl created a memory buffer for the newly added code, reconfigured Preprocessor and Lexer, created and entered a new TranslationUnit, and finally incrementally compiled the code. 

The above units constitute the libIncremental module.
